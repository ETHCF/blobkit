import { bls12_381 as bls } from '@noble/curves/bls12-381';
import {
  loadTrustedSetupFromBinary,
  loadTrustedSetupFromText
} from '../../src/kzg/setup';

// Mock fs/promises module
jest.mock('fs/promises', () => ({
  readFile: jest.fn()
}));

// Import after mock
import { readFile } from 'fs/promises';
const mockReadFile = readFile as jest.MockedFunction<typeof readFile>;

describe('Setup File Loading', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('loadTrustedSetupFromBinary', () => {
    it('should load valid binary files', async () => {
      // Create valid binary data
      const g1Gen = bls.G1.ProjectivePoint.BASE.toRawBytes(true);
      const g2Gen = bls.G2.ProjectivePoint.BASE.toRawBytes(true);
      const g2Tau = bls.G2.ProjectivePoint.BASE.multiply(12345n).toRawBytes(true);
      
      // Mock G1 data (4096 points)
      const g1Data = Buffer.alloc(4096 * 48);
      for (let i = 0; i < 4096; i++) {
        g1Data.set(g1Gen, i * 48);
      }
      
      // Mock G2 data (2 points)
      const g2Data = Buffer.concat([g2Gen, g2Tau]);
      
      mockReadFile
        .mockResolvedValueOnce(g1Data)
        .mockResolvedValueOnce(g2Data);
      
      const setup = await loadTrustedSetupFromBinary('g1.bin', 'g2.bin');
      
      expect(setup.g1Powers).toHaveLength(4096);
      expect(setup.g2Powers).toHaveLength(2);
      expect(setup.g1Powers[0].equals(bls.G1.ProjectivePoint.BASE)).toBe(true);
      expect(setup.g2Powers[0].equals(bls.G2.ProjectivePoint.BASE)).toBe(true);
    });

    it('should reject G1 file with wrong size', async () => {
      const wrongSizeData = Buffer.alloc(100);
      const g2Data = Buffer.alloc(2 * 96);
      
      mockReadFile
        .mockResolvedValueOnce(wrongSizeData)
        .mockResolvedValueOnce(g2Data);
      
      await expect(loadTrustedSetupFromBinary('g1.bin', 'g2.bin'))
        .rejects.toThrow('Expected 196608 bytes, got 100');
    });

    it('should reject G2 file with wrong size', async () => {
      const g1Data = Buffer.alloc(4096 * 48);
      const wrongSizeData = Buffer.alloc(50);
      
      mockReadFile
        .mockResolvedValueOnce(g1Data)
        .mockResolvedValueOnce(wrongSizeData);
      
      await expect(loadTrustedSetupFromBinary('g1.bin', 'g2.bin'))
        .rejects.toThrow('Expected 192 bytes, got 50');
    });

    it('should reject invalid G1 point data', async () => {
      // Create data with invalid point
      const g1Data = Buffer.alloc(4096 * 48);
      // Fill with invalid data (all 0xFF)
      g1Data.fill(0xFF, 0, 48);
      
      const g2Gen = bls.G2.ProjectivePoint.BASE.toRawBytes(true);
      const g2Data = Buffer.concat([g2Gen, g2Gen]);
      
      mockReadFile
        .mockResolvedValueOnce(g1Data)
        .mockResolvedValueOnce(g2Data);
      
      await expect(loadTrustedSetupFromBinary('g1.bin', 'g2.bin'))
        .rejects.toThrow();
    });

    it('should reject setup with non-generator first G1', async () => {
      // First G1 is not the generator
      const notGen = bls.G1.ProjectivePoint.BASE.multiply(2n).toRawBytes(true);
      const g1Gen = bls.G1.ProjectivePoint.BASE.toRawBytes(true);
      
      const g1Data = Buffer.alloc(4096 * 48);
      g1Data.set(notGen, 0); // First is not generator
      for (let i = 1; i < 4096; i++) {
        g1Data.set(g1Gen, i * 48);
      }
      
      const g2Gen = bls.G2.ProjectivePoint.BASE.toRawBytes(true);
      const g2Data = Buffer.concat([g2Gen, g2Gen]);
      
      mockReadFile
        .mockResolvedValueOnce(g1Data)
        .mockResolvedValueOnce(g2Data);
      
      await expect(loadTrustedSetupFromBinary('g1.bin', 'g2.bin'))
        .rejects.toThrow('First G1 power must be generator');
    });

    it('should reject setup with non-generator first G2', async () => {
      const g1Gen = bls.G1.ProjectivePoint.BASE.toRawBytes(true);
      const g1Data = Buffer.alloc(4096 * 48);
      for (let i = 0; i < 4096; i++) {
        g1Data.set(g1Gen, i * 48);
      }
      
      // First G2 is not generator
      const notGen = bls.G2.ProjectivePoint.BASE.multiply(2n).toRawBytes(true);
      const g2Gen = bls.G2.ProjectivePoint.BASE.toRawBytes(true);
      const g2Data = Buffer.concat([notGen, g2Gen]);
      
      mockReadFile
        .mockResolvedValueOnce(g1Data)
        .mockResolvedValueOnce(g2Data);
      
      await expect(loadTrustedSetupFromBinary('g1.bin', 'g2.bin'))
        .rejects.toThrow('First G2 power must be generator');
    });

    it('should handle file read errors', async () => {
      mockReadFile.mockRejectedValueOnce(new Error('File not found'));
      
      await expect(loadTrustedSetupFromBinary('missing.bin', 'g2.bin'))
        .rejects.toThrow('File not found');
    });
  });

  describe('loadTrustedSetupFromText', () => {
    it('should load valid text files', async () => {
      const g1Hex = bls.G1.ProjectivePoint.BASE.toHex();
      const g2Hex = bls.G2.ProjectivePoint.BASE.toHex();
      const g2TauHex = bls.G2.ProjectivePoint.BASE.multiply(12345n).toHex();
      
      // Create text content
      const g1Content = Array(4096).fill(g1Hex).join('\n');
      const g2Content = `${g2Hex}\n${g2TauHex}`;
      
      mockReadFile
        .mockResolvedValueOnce(g1Content)
        .mockResolvedValueOnce(g2Content);
      
      const setup = await loadTrustedSetupFromText('g1.txt', 'g2.txt');
      
      expect(setup.g1Powers).toHaveLength(4096);
      expect(setup.g2Powers).toHaveLength(2);
      expect(setup.g1Powers[0].equals(bls.G1.ProjectivePoint.BASE)).toBe(true);
      expect(setup.g2Powers[0].equals(bls.G2.ProjectivePoint.BASE)).toBe(true);
    });

    it('should handle empty lines and whitespace', async () => {
      const g1Hex = bls.G1.ProjectivePoint.BASE.toHex();
      const g2Hex = bls.G2.ProjectivePoint.BASE.toHex();
      
      // Add empty lines and whitespace
      const g1Lines = [];
      for (let i = 0; i < 4096; i++) {
        g1Lines.push(g1Hex);
        if (i % 100 === 0) {
          g1Lines.push(''); // Empty line
          g1Lines.push('  '); // Whitespace
        }
      }
      
      const g2Content = `\n${g2Hex}\n\n  \n${g2Hex}\n`;
      
      mockReadFile
        .mockResolvedValueOnce(g1Lines.join('\n'))
        .mockResolvedValueOnce(g2Content);
      
      const setup = await loadTrustedSetupFromText('g1.txt', 'g2.txt');
      
      expect(setup.g1Powers).toHaveLength(4096);
      expect(setup.g2Powers).toHaveLength(2);
    });

    it('should reject file with wrong number of G1 points', async () => {
      const g1Content = Array(100).fill('0x123').join('\n');
      const g2Content = '0x456\n0x789';
      
      mockReadFile
        .mockResolvedValueOnce(g1Content)
        .mockResolvedValueOnce(g2Content);
      
      await expect(loadTrustedSetupFromText('g1.txt', 'g2.txt'))
        .rejects.toThrow('Expected 4096 G1 points, got 100');
    });

    it('should reject file with wrong number of G2 points', async () => {
      const g1Hex = bls.G1.ProjectivePoint.BASE.toHex();
      const g1Content = Array(4096).fill(g1Hex).join('\n');
      const g2Content = '0x123\n0x456\n0x789'; // 3 points instead of 2
      
      mockReadFile
        .mockResolvedValueOnce(g1Content)
        .mockResolvedValueOnce(g2Content);
      
      await expect(loadTrustedSetupFromText('g1.txt', 'g2.txt'))
        .rejects.toThrow('Expected 2 G2 points, got 3');
    });

    it('should reject invalid hex in G1 file', async () => {
      const g1Hex = bls.G1.ProjectivePoint.BASE.toHex();
      const g1Lines = Array(4095).fill(g1Hex);
      g1Lines.push('invalid-hex-data'); // Invalid on last line
      
      const g2Hex = bls.G2.ProjectivePoint.BASE.toHex();
      const g2Content = `${g2Hex}\n${g2Hex}`;
      
      mockReadFile
        .mockResolvedValueOnce(g1Lines.join('\n'))
        .mockResolvedValueOnce(g2Content);
      
      await expect(loadTrustedSetupFromText('g1.txt', 'g2.txt'))
        .rejects.toThrow('Invalid G1 point at line 4096');
    });

    it('should reject invalid hex in G2 file', async () => {
      const g1Hex = bls.G1.ProjectivePoint.BASE.toHex();
      const g1Content = Array(4096).fill(g1Hex).join('\n');
      
      const g2Hex = bls.G2.ProjectivePoint.BASE.toHex();
      const g2Content = `${g2Hex}\ninvalid-g2-point`;
      
      mockReadFile
        .mockResolvedValueOnce(g1Content)
        .mockResolvedValueOnce(g2Content);
      
      await expect(loadTrustedSetupFromText('g1.txt', 'g2.txt'))
        .rejects.toThrow('Invalid G2 point at line 2');
    });

    it('should handle various line endings', async () => {
      const g1Hex = bls.G1.ProjectivePoint.BASE.toHex();
      const g2Hex = bls.G2.ProjectivePoint.BASE.toHex();
      
      // Mix different line endings
      const g1Lines = Array(4096).fill(g1Hex);
      const g1Content = g1Lines.join('\r\n'); // Windows style
      
      const g2Content = `${g2Hex}\r${g2Hex}`; // Mac style
      
      mockReadFile
        .mockResolvedValueOnce(g1Content)
        .mockResolvedValueOnce(g2Content);
      
      const setup = await loadTrustedSetupFromText('g1.txt', 'g2.txt');
      
      expect(setup.g1Powers).toHaveLength(4096);
      expect(setup.g2Powers).toHaveLength(2);
    });

    it('should trim whitespace from hex values', async () => {
      const g1Hex = bls.G1.ProjectivePoint.BASE.toHex();
      const g2Hex = bls.G2.ProjectivePoint.BASE.toHex();
      
      // Add spaces and tabs
      const g1Lines = Array(4096).fill(`  ${g1Hex}\t `);
      const g2Content = `\t${g2Hex}  \n  ${g2Hex}\t`;
      
      mockReadFile
        .mockResolvedValueOnce(g1Lines.join('\n'))
        .mockResolvedValueOnce(g2Content);
      
      const setup = await loadTrustedSetupFromText('g1.txt', 'g2.txt');
      
      expect(setup.g1Powers).toHaveLength(4096);
      expect(setup.g2Powers).toHaveLength(2);
    });
  });
});